% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
%\documentclass[14pt]{matmex-diploma}
\documentclass[14pt]{matmex-diploma-custom}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
%    chair              = {Лабораторная работа №1 по дисциплине «Технологии искусственного интеллекта»},
    title              = {Изучение классических методов поиска – градиентного спуска и моделирования отжига},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    %   labwork - лабораторная работа
    type               = {labwork},
    subtitle           = {Лабораторная работа №1 по дисциплине «Технологии искусственного интеллекта»},
    position           = {студента},
    group              = V3316,
    author             = Перестюк Анастасия},
%    supervisorPosition = {к.т.н.\, доцент каф. КФиВИ},
    supervisor         = {Щербаков О.\,В.},
%    reviewerPosition   = {ст. преп.},
%    reviewer           = {Привалов А.\,И.},
%    chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
%    chairHead          = {Хунта К.\,Х.},
   university         = {Университет ИТМО},
   faculty            = {Факультет фотоники и оптоинформатики},
   city               = {Санкт-Петербург},
   year               = {2016}
}
\maketitle
\tableofcontents

\section*{Цель работы}
Ознакомление с методами поиска в непрерывном пространстве состояний в
случаях отсутствия и наличия вторичных минимумов

\section*{Задание}

\begin{enumerate}
    \item Изучить теоретическую часть работы.
    \item Реализовать методы градиентного спуска и имитации отжига.
    \item Для функций двух видов: вогнутой и с вторичными минимумами применить методы поиска, оценить скорость их сходимости и возможность нахождения глобального минимума.
\end{enumerate}

\section{Метод градиентного спуска}
Градиентный спуск — метод нахождения локального экстремума (минимума или
максимума) функции с помощью движения вдоль градиента. Для минимизации функции в
направлении градиента используются методы одномерной оптимизации, например, метод
золотого сечения. Также можно искать не наилучшую точку в направлении градиента, а
какую-либо лучше текущей.
\par
Градиент некоторой функции $f(x)$ в некоторой точке показывает направление
локального наискорейшего увеличения функции. Этот факт используется в методах
градиентного спуска (подъема).
\par
Данный метод использует значение градиента функции в текущем положении для
определения следующего. При использовании адаптивного шага функции можно
вычислить значение минимума с заданной точностью:

\begin{equation}
    \label{частные_производные}
    \nabla f(x) = [ \frac{\partial f}{\partial x_1} ..., \frac{\partial f}{\partial x_n} ]
\end{equation}
Положение следующей точки:
\begin{equation}
    \label{следующая_точка}
    \nabla f(x) = x_{i+1} = x_i - d\frac{\nabla f(x_i)}{|\nabla f(x_i)|} 
\end{equation}
где d – параметр, определяющий скорость спуска, и положить i=i+1.
\newline
Критерий остановки:
\begin{equation}
    \label{критерий_остановки}
    |x_i - x_{i-1}| > s ]
\end{equation}

Существует несколько способов ввода критерия останова. Самый простой – это
наложить ограничение на количество итераций. Другие способы связаны с проверкой
того, что текущая точка или значение функции \(f\) меняются мало.
\par
При условии существования глобального минимума функции \(f\) метод
градиентного спуска обычно сходится (за исключением случаев, когда вдоль некоторого
направления функция стремится к некоторому конечному пределу при
\( |f| \to \infty) \)
Хотя метод сходится, он не гарантирует нахождения глобального минимума, поскольку при
достижении любого локально минимума метод не в состоянии определить направление на
более глубокий минимум (и вообще обнаружить его существование) и останавливается в
соответствии с выбранным критерием останова. Можно сказать, что данный метод
«застревает» в локальных минимумах.
\par
В связи с этим, выбор начальной точки может существенно сказаться на
полученном результате.

\clearpage
\paragraph{Практическая часть}
Графики зависимости расстояния до минимума от числа итераций приведены на рисунке~\ref{gradient}.
Для всех функций начальная точка (24, 32), а для наглядности графиков максимальное количество итераций равно 500.

\par
Исследуемые функции:

\begin{enumerate}
    \item \( f1(x,y) = 0.5x^2+0.9(y-7)^2 \)
    \item \( f2(x,y) = 17(x-1)^2+0.3(y+6)^2 \)
    \item \( f3(x,y) = 2x^2+0.5y^2 \)
\end{enumerate}

\begin{figure}[h]
    \center
    \includegraphics{g1.png}
    \caption{График зависимости расстояния до минимума от итераций для функции с одним минимумом}
    \label{gradient}    
\end{figure}

Теперь рассмотрим функцию с несколькими минимумами вида \newline
\( z = 10 \frac{sin (5x^2 + \pi y ^2)}{5x^2 + \pi y ^2} \), график которой приведен на рисунке~\ref{megafunc}. \)
попробуем найти для неё минимум, при этом важно помнить, 
что можно попасть в локальный минимум, как можно видеть на рисунке~\ref{crazy}, где для точки (3, 3) функция попадает в другое значение.

\begin{figure}[h]
    \center
    \includegraphics{func.png}
    \caption{Функция с несколькими локальными минимумами}
    \label{megafunc}    
\end{figure}
\begin{figure}[h]
    \center
    \includegraphics{g2.png}
    \caption{График зависимости расстояния до минимума от количества итераций для функции с несколькими минимумами для двух различных точек}
    \label{crazy}    
\end{figure}

\section{Метод имитации отжига}
Метод моделирования отжига предназначен для поиска глобального минимума
некоторой функции \( f:S \to R \) , где \( S \) – некоторое пространство (необязательно
непрерывное), элементы которого интерпретируются как состояния некоторой
воображаемой физической системы, а значения самой функции – как энергия этой
системы \( E=f(x) \) в состоянии \( x \in S \).
\par
В методе моделирования отжига система в каждый момент времени находится в
некотором состоянии xi
, а также обладает некоторой температурой T, которая является
управляемым параметром. На каждой итерации система случайным образом переходит в
новое состояние. Оно выбирается по нормальному распределению:
\begin{equation}
    \label{распределение}
    g(x_i, X_{i+1},T) = (2 \pi T)^{D/2}exp(-\frac{|x_{i+1} - x_i|^2}{2T})
\end{equation}
где $D$ - разрядность пространства $S$
\par
Вероятность перехода в это состояние равна:
\begin{equation}
    \label{вероятность}
    h(\delta E, T) = \frac {1} {1 + exp (\frac{\delta E}{T})} \aprox - \frac{\delta E}{T}
\end{equation}
где \( \delta E = f (x_{i+1} - f(x) \). \newline
Таким образом, температура $T$ определяет, насколько в среднем
может меняться текущее состояние $X_i$, а также то, насколько в среднем может меняться
энергия системы при переходе в новое состояние.
Поскольку переход в состояние с меньшей энергией более вероятен, чем переход
в состояние с большей, то система будет больше времени проводить именно в
низкоэнергетических состояниях. Для обеспечения сходимости системы к некоторому
состоянию температуру понижают с переходом к следующей итерации по закону:
\begin{equation}
    \label{закон_температуры}
    T_i = \frac {T_0} {ln(1 + i)}
\end{equation}
где номер итерации $i > 0$ \newline
В связи с этим используется более быстрое понижение температуры:
\begin{equation}
    \label{закон_температуры}
    T_i = \frac {T_0} {1 + i}
\end{equation}
\par
Начальная температура неявно задает область, в которой будет осуществляться
поиск глобального минимума, а также определяет необходимое для сходимости число
итераций.

\clearpage
\paragraph{Практическая часть}
Для начала воспользуемся данным методом для тех же самых функций с той же начальной точкой (24, 32), температуру возьмем равной 1000.
Графики зависимости представлены на рисунке~\ref{an1}. Как видно из графика, при понижении температуры, он становится более гладким. Именно такие случайные изменения температуры позволяют выйти из локального минимума.

\clearpage

Теперь попробуем исследовать влияние температуры на поиск глобального минимума для функций с одним минимумом 
(рис.\ref{an2}) и с несколькими(рис.\ref{an2}). 
Из графиков видно, что при низкой температуре скорость схождения графика в какой-то момент становится нулевой. 
То есть, функция никогда не достигнет локального минимума.
При высокой температуре наоборот, наблюдаются большие колебания, которые долго затухают.
Аналогичная картина наблюдается и в случае функции с несколькими минимумами (рис.\ref{an3}). 
При недостаточной температуре функция скатывается в локальный минимум и не может из него выбраться. 

\begin{figure}[h]
    \center
    \includegraphics{a1.png}
    \caption{График зависимости расстояния до минимума от итераций для функции с одним минимумом (T=50)}
    \label{an1}    
\end{figure}
\begin{figure}[h]
    \center
    \includegraphics{a2.png}
    \caption{График зависимости расстояния до минимума от итераций для функции с одним минимумом (T=200)}
    \label{an2}    
\end{figure}
\begin{figure}[h]
    \center
    \includegraphics{a3.png}
    \caption{График зависимости расстояния до минимума от итераций для функции с несколькими минимумами при различных температурах}
    \label{an3}    
\end{figure}

\clearpage
\section*{Вывод}
При выполнении данной работы я ознакомилась с методами поиска глобального
минимума в непрерывном пространстве: метод градиентного спуска и имитация отжига.
\par
Метод градиентного спуска гарантированно хорошо работает для функций с одним глобальным минимумом. 
Метод имитации отжига позволяет обойти эту проблему и найти глобальный минимум, но только при правильно подобранной температуре, к тому же он не дает никаких гарантий на нахождение минимума.

\section*{Приложение А. Листинг программы}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}

\begin{minted}[fontsize=\small, breaklines=true]{cpp}

#include <iostream>
#include <fstream>
#include <functional>
#include <cmath>
#include <limits>
#include <random>
#include <vector>

// некоторые константы
const double eps = 0.0001; // заданная точность
const double h = 0.000000001; // приращение аргумента

// тип исследуемой функции (возвращает double, принимает два аргумента типа double)
typedef std::function<double (double x, double y)> my_function;

/// набор исследуемых функий
double func1(double x, double y)
{
    return 0.5*std::pow(x,2)+0.9*std::pow(y-7, 2);
}

double func2(double x, double y)
{
    return 17*std::pow(x-1,2)+0.3*std::pow(y+6,2);
}

double func3(double x, double y)
{
    return 2*std::pow(x,2)+0.5*std::pow(y,2);
}

double func4(double x, double y)
{
    return -10 * std::sin(5*std::pow(x,2)+M_PI*std::pow(y,2))/(5*std::pow(x,2)+M_PI*std::pow(y,2));
}

struct point
{
    double x;
    double y;

    point(double x_, double y_) : x(x_), y(y_) {}
    point() {}
};

struct result {
    point p; // конечная точка
    std::vector<double> steps; // итерации
};

/// метод градиентного спуска

// програмно считаем производную по x
double d_x(my_function f, double x, double y)
{
    double a1 = f(x - h * 0.5, y);
    double a2 = f(x + h * 0.5, y);
    return (a2 - a1) / h;
}

// програмно считаем производную по y
double d_y(my_function f, double x, double y)
{
    double a1 = f(x, y - h * 0.5);
    double a2 = f(x, y + h * 0.5);
    return (a2 - a1) / h;
}

double length(double x, double y)
{
    return std::sqrt(x * x + y * y);
}

// простой градиентный спуск
result gradient(my_function f, point p, point to, int iters, double d)
{
    result r;

    point p0 = p;
    double fp0 = f(p0.x, p0.y);
    for (int i = 0; i < iters; ++i) {
        double dx = d_x(f, p.x, p.y);
        double dy = d_y(f, p.x, p.y);
        double n = length(dx, dy);

        p.x -= d * (dx / n);
        p.y -= d * (dy / n);

        // вычисляем расстояние до истинного минимума
        dx = std::abs(p.x - to.x);
        dy = std::abs(p.y - to.y);
        double l = length(dx, dy);
        r.steps.push_back(l);

        // вычисляем дельту между предыдущим и этим шагом и выходим если она становится меньше eps
        double fp = f(p.x, p.y);
        l = std::abs(fp - fp0);
        if (l < eps) {
            //break; на самом деле выключаем ради графиков
        }
        p0 = p;
        fp0 = fp;
    }
    std::cout << "f("  << p.x << ", " << p.y << ") = " << f(p.x, p.y) << std::endl;
    r.p = p;
    return r;
}

/// метод имитации отжига

/// вероятность перехода
double h_prob(double dE, double T)
{
    double r = 1.0 / (1.0 + std::exp(dE / T));
    return r;
}

/// уменьшение температуры
double dec_temperature(double T, int iter)
{
    return T / (1.0 + iter);
}

/// значение энергии
double delta_energy(my_function f, point a, point b)
{
    double r1 = f(b.x, b.y);
    double r2 = f(a.x, a.y);
    return r2 - r1;
}

// метод имитации отжига
result annealing(my_function f, point p, point to, int iters, double T_0)
{
    result r;
    // генератор случайных чисел
    std::random_device rd;
    std::mt19937 gen(rd());

    double T = T_0;
    for (int i = 0; i < iters; ++i) {
        // нормальное распределение, с помощью него высчитываем новое значение точки
        std::normal_distribution<double> distx(p.x, std::sqrt(T));
        std::normal_distribution<double> disty(p.y, std::sqrt(T));

        point n_p(0, 0);
        n_p.x = distx(gen);
        n_p.y = disty(gen);

        double de = delta_energy(f, n_p, p);

        // новое значение энергии лучше
        if (de < 0) {
            p = n_p;
        } else {
            double probality = h_prob(de, T);
            double v = double(rand()) / double(RAND_MAX);
            if (v <= probality) {
                p = n_p;
            }
        }
        T = dec_temperature(T_0, i);

        // вычисляем расстояние до истинного минимума
        double dx = std::abs(p.x - to.x);
        double dy = std::abs(p.y - to.y);
        double l = length(dx, dy);

        r.steps.push_back(l);
    }
    std::cout << "f("  << p.x << ", " << p.y << ") = " << f(p.x, p.y) << std::endl;
    r.p = p;
    return r;
}

int main(int, char **)
{
    std::srand(time(nullptr));

    point po(24, 32);

    int its = 800; //количество итераций (намерено ограничиваем так, чтобы график получился наглядным)
    std::cout << "g1" << std::endl;

    { // вложеный блок, чтобы не ошибиться случайно
        result r1 = gradient(func1, po, point(0, 7), its, 0.1);
        result r2 = gradient(func2, po, point(1, -6), its, 0.1);
        result r3 = gradient(func3, po, point(0, 0), its, 0.1);

        std::ofstream out("g1.csv");
        out << "i;f1;f2;f3" << std::endl;
        for (int i = 0; i < its; ++i) {
            out << i << ";"
                << r1.steps[i] << ";"
                << r2.steps[i] << ";"
                << r3.steps[i] << std::endl;

        }
    }

    std::cout << "g2" << std::endl;
    { // вложеный блок, чтобы не ошибиться случайно
        result r1 = gradient(func4, point(0.5, 0.5), point(0, 0), its, 0.001);
        result r2 = gradient(func4, point(3, 3), point(0, 0), its, 0.001);

        std::ofstream out("g2.csv");
        out << "i;(0.5, 0.5);(3, 3);" << std::endl;
        for (int i = 0; i < its; ++i) {
            out << i << ";"
                << r1.steps[i] << ";"
                << r2.steps[i] << std::endl;

        }
    }

    std::cout << "a1" << std::endl;
    { // вложеный блок, чтобы не ошибиться случайно
        result r1 = annealing(func1, po, point(0, 7), its, 50);
        result r2 = annealing(func2, po, point(1, -6), its, 50);
        result r3 = annealing(func3, po, point(0, 0), its, 50);

        std::ofstream out("a1.csv");
        out << "i;f1;f2;f3" << std::endl;
        for (int i = 0; i < its; ++i) {
            out << i << ";"
                << r1.steps[i] << ";"
                << r2.steps[i] << ";"
                << r3.steps[i] << std::endl;

        }
    }

    std::cout << "a2" << std::endl;
    { // вложеный блок, чтобы не ошибиться случайно
        result r1 = annealing(func1, po, point(0, 7), its, 200);
        result r2 = annealing(func2, po, point(1, -6), its, 200);
        result r3 = annealing(func3, po, point(0, 0), its, 200);

        std::ofstream out("a2.csv");
        out << "i;f1;f2;f3" << std::endl;
        for (int i = 0; i < its; ++i) {
            out << i << ";"
                << r1.steps[i] << ";"
                << r2.steps[i] << ";"
                << r3.steps[i] << std::endl;

        }
    }

    std::cout << "a3" << std::endl;
    { // вложеный блок, чтобы не ошибиться случайно
        result r1 = annealing(func4, point(1, 1), point(0, 0), its, 0.5);
        result r2 = annealing(func4, point(1, 1), point(0, 0), its, 5);
        result r3 = annealing(func4, point(1, 1), point(0, 0), its, 50);

        std::ofstream out("a3.csv");
        out << "i;T=0.5;T=5;T=50" << std::endl;
        for (int i = 0; i < its; ++i) {
            out << i << ";"
                << r1.steps[i] << ";"
                << r2.steps[i] << ";"
                << r3.steps[i] << std::endl;

        }
    }
}


\end{minted}

\end{document}
